/*****************************************************************************************************************/

//	@author		Michael Roberts <michael@observerly.com>
//	@package	@observerly/skysolve
//	@license	Copyright Â© 2021-2025 observerly

/*****************************************************************************************************************/

package solve

/*****************************************************************************************************************/

import (
	"errors"
	"fmt"
	"math"
	"sort"
	"sync"

	"github.com/observerly/iris/pkg/photometry"
	stats "github.com/observerly/iris/pkg/statistics"

	"github.com/observerly/skysolve/pkg/catalog"
	"github.com/observerly/skysolve/pkg/geometry"
	"github.com/observerly/skysolve/pkg/quad"
	"github.com/observerly/skysolve/pkg/spatial"
	"github.com/observerly/skysolve/pkg/star"
	"github.com/observerly/skysolve/pkg/wcs"
)

/*****************************************************************************************************************/

type PlateSolver struct {
	Stars       []photometry.Star
	Sources     []catalog.Source
	Data        []float32
	RA          float64
	Dec         float64
	Width       int
	Height      int
	PixelScaleX float64
	PixelScaleY float64
}

/*****************************************************************************************************************/

type Params struct {
	Data                []float32
	Width               int
	Height              int
	PixelScaleX         float64
	PixelScaleY         float64
	ADU                 int32
	ExtractionThreshold float64
	Radius              float64
	Sigma               float64
}

/*****************************************************************************************************************/

type ToleranceParams struct {
	QuadTolerance           float64 // default quad tolerance in normalised 4D space of 0.1
	EuclidianPixelTolerance float64 // default euclidian pixel tolerance of 10 pixels
}

/*****************************************************************************************************************/

// NewPlateSolver initializes a new PlateSolver with the given FITS image and parameters.
func NewPlateSolver(
	params Params,
) (*PlateSolver, error) {
	radius := params.Radius
	sigma := params.Sigma
	stars := []photometry.Star{}
	sources := []catalog.Source{}

	// Calculate the width of the image in pixels:
	xs := params.Width

	// Calculate the height of the image in pixels:
	ys := params.Height

	// Setup a wait group for the stars extractor:
	var wg sync.WaitGroup
	wg.Add(1)

	// Extract bright pixels (stars) from the image:
	go func() {
		defer wg.Done()

		// Extract the image from the FITS file:
		sexp := photometry.NewStarsExtractor(params.Data, xs, ys, float32(radius), params.ADU)

		// Extract the bright pixels from the image:
		starsExtracted := sexp.FindStars(stats.NewStats(params.Data, params.ADU, xs), float32(sigma), 2.2)

		// Sort the stars by intensity, in descending order:
		sort.Slice(starsExtracted, func(i, j int) bool {
			return starsExtracted[i].Intensity > starsExtracted[j].Intensity
		})

		// Get a minimum of X stars from our list of stars, e.g., the brightest X stars:
		k := math.Min(float64(len(starsExtracted)), params.ExtractionThreshold)

		stars = starsExtracted[:int(k)]
	}()

	// Wait for the stars extractor to finish
	wg.Wait()

	// Return a new PlateSolver object with the catalog, stars, sources, RA, Dec, and pixel scale:
	return &PlateSolver{
		Stars:   stars,
		Sources: sources,
		Data:    params.Data,
		Width:   xs,
		Height:  ys,
	}, nil
}

/*****************************************************************************************************************/

// GenerateEuclidianStarQuads generates quads from the provided stars with parallelization:
// We spawn a goroutine for every (i, j) pair to handle the (k, l) loops and generate quads.
func GenerateEuclidianStarQuads(stars []star.Star, precision int) ([]quad.Quad, error) {
	// Check if there are enough stars to form at least one quad:
	if len(stars) < 4 {
		return nil, errors.New("not enough stars to form a quad")
	}

	// Helper function to determine if two stars share identical coordinates:
	// This helps avoid zero-distance computations and ensures quads consist of unique stars:
	sameCoords := func(s1, s2 star.Star) bool {
		return s1.X == s2.X && s1.Y == s2.Y
	}

	// Channel to collect quads generated by all goroutines:
	// Buffered channel to prevent blocking when multiple goroutines send data concurrently:
	results := make(chan []quad.Quad, len(stars)*(len(stars)-1)/2)

	// WaitGroup to track the completion of all worker goroutines:
	var wg sync.WaitGroup

	// WaitGroup to track the completion of the collector goroutine:
	var collectorWg sync.WaitGroup

	// Slice to store all generated quads:
	var quads []quad.Quad

	// Start the collector goroutine to aggregate quads from the results channel:
	collectorWg.Add(1)
	go func() {
		defer collectorWg.Done()

		// Continuously read from the results channel until it's closed:
		for res := range results {
			if len(res) > 0 {
				quads = append(quads, res...)
			}
		}
	}()

	// Iterate through all unique combinations of two stars (i, j):
	for i := 0; i < len(stars)-3; i++ {
		a := stars[i]

		for j := i + 1; j < len(stars)-2; j++ {
			b := stars[j]

			// Increment the WaitGroup counter before spawning a new goroutine:
			wg.Add(1)

			// Spawn a goroutine for each (i, j) pair to handle (k, l) loops:
			go func(a, b star.Star, startK int) {
				defer wg.Done() // Signal completion when the goroutine finishes:

				// Slice to hold quads generated by this goroutine:
				quads := []quad.Quad{}

				// Skip processing if stars a and b share the same coordinates:
				if sameCoords(a, b) {
					// No valid quad can be formed with identical stars:
					results <- quads // Send an empty slice to the results channel:
					return
				}

				// Calculate the distance between stars a and b:
				distAB := geometry.DistanceBetweenTwoCartesianPoints(a.X, a.Y, b.X, b.Y)
				if distAB == 0 {
					// If the distance is zero, stars a and b occupy the same position:
					results <- quads // Send an empty slice to the results channel:
					return
				}

				// Iterate through all possible third stars (k) for the current (i, j) pair:
				for k := startK; k < len(stars)-1; k++ {
					c := stars[k]

					// Ensure star c does not share coordinates with stars a or b:
					if sameCoords(a, c) || sameCoords(b, c) {
						continue // Skip to the next star if coordinates overlap:
					}

					// Calculate the distance between stars a and c:
					distAC := geometry.DistanceBetweenTwoCartesianPoints(a.X, a.Y, c.X, c.Y)
					if distAC == 0 {
						continue // Skip if the distance is zero:
					}

					// Calculate the distance between stars b and c:
					distBC := geometry.DistanceBetweenTwoCartesianPoints(b.X, b.Y, c.X, c.Y)
					if distBC == 0 {
						continue // Skip if the distance is zero:
					}

					// Iterate through all possible fourth stars (l) for the current (i, j, k) triplet:
					for l := k + 1; l < len(stars); l++ {
						d := stars[l]

						// Ensure star d does not share coordinates with stars a, b, or c:
						if sameCoords(a, d) || sameCoords(b, d) || sameCoords(c, d) {
							continue // Skip to the next star if coordinates overlap:
						}

						// Calculate distances between star d and stars a, b, c:
						distAD := geometry.DistanceBetweenTwoCartesianPoints(a.X, a.Y, d.X, d.Y)
						if distAD == 0 {
							continue // Skip if the distance is zero:
						}

						distBD := geometry.DistanceBetweenTwoCartesianPoints(b.X, b.Y, d.X, d.Y)
						if distBD == 0 {
							continue // Skip if the distance is zero:
						}

						distCD := geometry.DistanceBetweenTwoCartesianPoints(c.X, c.Y, d.X, d.Y)
						if distCD == 0 {
							continue // Skip if the distance is zero:
						}

						// Attempt to create a new Quad from the four stars:
						// This may fail if normalization fails, in which case we skip this combination:
						q, err := quad.NewQuad(a, b, c, d, precision)
						if err != nil {
							continue // Skip this quad if normalization fails:
						}

						// Append the successfully created quad to the local slice:
						quads = append(quads, q)
					}
				}

				// Send all quads generated by this goroutine to the results channel:
				results <- quads
			}(a, b, j+1) // Pass stars a, b, and the starting index for k to the goroutine:
		}
	}

	// Wait for all worker goroutines to complete their execution:
	wg.Wait()

	// Close the results channel to signal the collector goroutine that no more data will be sent:
	close(results)

	// Wait for the collector goroutine to finish aggregating all quads:
	collectorWg.Wait()

	// Return the aggregated list of quads:
	return quads, nil
}

/*****************************************************************************************************************/

// ValidateAndConfirmMatches iterates through pairs of candidate matches, computes affine transformations,
// applies them, and retains only those matches where both quads align within the specified tolerance.
func (ps *PlateSolver) ValidateAndConfirmMatches(candidateMatches []spatial.QuadMatch, tolerance float64) ([]spatial.QuadMatch, error) {
	if len(candidateMatches) == 0 {
		return []spatial.QuadMatch{}, errors.New("no candidate matches provided")
	}

	matches := []spatial.QuadMatch{}
	maximumConfirmations := 0

	// Create a wait group to wait for all goroutines to finish:
	wg := sync.WaitGroup{}

	// Add the number of candidate matches to the wait group:
	wg.Add(len(candidateMatches))

	for _, match := range candidateMatches {
		// Initialize a slice to hold confirming matches for the current quad:
		var confirmingMatches []spatial.QuadMatch

		// Assuming ComputeAffineTransformation expects a slice of spatial.QuadMatch and uses the Quad points within
		// the spatial.QuadMatch to compute the affine transformation matrix:
		params, xr, yr, err := wcs.ComputeAffineTransformation([]spatial.QuadMatch{match})
		if err != nil {
			return nil, err
		}

		// Create a new WCS object with the affine transformation matrix:
		WCS := wcs.NewWorldCoordinateSystem(
			xr,
			yr,
			wcs.WCSParams{
				Projection:   wcs.RADEC_TAN,
				AffineParams: params,
			},
		)

		// Ensure the affine transformation is invertible by checking the determinant of the matrix:
		determinant := params.A*params.E - params.B*params.D
		if determinant == 0 {
			fmt.Println("affine transformation is not invertible for match:", match.Quad.GetHashCodeAsString())
			continue // Skip this match as it cannot be inverted for WCS
		}

		// Now for all other candidate matches, apply the affine transformation and validate the match:
		for _, candidate := range candidateMatches {
			// Check that the candidate is not the same as the current match:
			if candidate.Quad.GetHashCodeAsString() == match.Quad.GetHashCodeAsString() {
				continue
			}

			// Original pixel coordinates of the candidate's quad points (A, B, C, D):
			aX, aY := candidate.Quad.A.X, candidate.Quad.A.Y
			// Apply the inverse affine transformation to get transformed pixel coordinates of the candidate's quad points:
			xa, ya := WCS.EquatorialCoordinateToPixel(candidate.Quad.A.RA, candidate.Quad.A.Dec)

			bX, bY := candidate.Quad.B.X, candidate.Quad.B.Y
			xb, yb := WCS.EquatorialCoordinateToPixel(candidate.Quad.B.RA, candidate.Quad.B.Dec)

			cX, cY := candidate.Quad.C.X, candidate.Quad.C.Y
			xc, yc := WCS.EquatorialCoordinateToPixel(candidate.Quad.C.RA, candidate.Quad.C.Dec)

			dX, dY := candidate.Quad.D.X, candidate.Quad.D.Y
			xd, yd := WCS.EquatorialCoordinateToPixel(candidate.Quad.D.RA, candidate.Quad.D.Dec)

			// Calculate the Euclidean distance between the two sets of points:
			distA := math.Hypot(aX-xa, aY-ya)
			distB := math.Hypot(bX-xb, bY-yb)
			distC := math.Hypot(cX-xc, cY-yc)
			distD := math.Hypot(dX-xd, dY-yd)

			// If the distance between the two sets of points is within the specified tolerance, then we have a match:
			if distA <= tolerance && distB <= tolerance && distC <= tolerance && distD <= tolerance {
				confirmingMatches = append(confirmingMatches, candidate)
			}
		}

		// Update the matches slice with the confirmed matches if they have the most confirmations
		if len(confirmingMatches) > maximumConfirmations {
			maximumConfirmations = len(confirmingMatches)
			// Update the matches slice with the confirmed matches, including the original match
			matches = append([]spatial.QuadMatch{}, confirmingMatches...)
			matches = append(matches, match)
		}
	}

	return matches, nil
}

/*****************************************************************************************************************/

func (ps *PlateSolver) Solve(tolerance ToleranceParams, sipOrder int) (*wcs.WCS, []spatial.QuadMatch, error) {
	stars := make([]star.Star, len(ps.Stars))

	sources := make([]star.Star, len(ps.Sources))

	wg := sync.WaitGroup{}

	wg.Add(2)

	go func() {
		defer wg.Done()

		for i, s := range ps.Stars {
			stars[i] = star.Star{
				Designation: "Unknown",
				X:           float64(s.X),
				Y:           float64(s.Y),
				RA:          math.Inf(1),
				Dec:         math.Inf(1),
				Intensity:   float64(s.Intensity),
			}
		}
	}()

	go func() {
		defer wg.Done()

		for _, source := range ps.Sources {
			sources = append(sources, star.Star{
				Designation: source.Designation,
				X:           source.RA,
				Y:           source.Dec,
				RA:          source.RA,
				Dec:         source.Dec,
				Intensity:   source.PhotometricGMeanFlux,
			})
		}
	}()

	quads := []quad.Quad{}

	sourceQuads := []quad.Quad{}

	wg.Wait()

	wg.Add(2)

	go func() {
		defer wg.Done()

		// Generate our quads from the extracted stars:
		qs, err := GenerateEuclidianStarQuads(stars, 3)

		if err != nil {
			return
		}

		quads = qs
	}()

	go func() {
		defer wg.Done()

		// Generate our source quads from the sources:
		qs, err := GenerateEuclidianStarQuads(sources, 3)

		if err != nil {
			return
		}

		sourceQuads = qs
	}()

	wg.Wait()

	// Create a new matcher with the generated quads:
	matcher, err := spatial.NewQuadMatcher(quads)
	if err != nil {
		return nil, nil, err
	}

	// Match the generated quads with the source quads for a given tolerance:
	candidateMatches, err := matcher.MatchQuads(sourceQuads, tolerance.QuadTolerance)
	if err != nil {
		return nil, nil, err
	}

	// Now we have our candidate matches, we need to further verify them by comparing the stars within the quads.
	// Validate and confirm matches by applying affine transformations and checking for alignment within the specified tolerance:
	matches, err := ps.ValidateAndConfirmMatches(candidateMatches, tolerance.EuclidianPixelTolerance)
	if err != nil {
		return nil, nil, err
	}

	// Compute the final affine transformation matrix:
	params, xr, yr, err := wcs.ComputeAffineTransformation(matches)
	if err != nil {
		return nil, nil, err
	}

	// Calculate the x-coordinate of the center of the image:
	xc := float64(ps.Width) / 2.0

	// Calculate the y-coordinate of the center of the image:
	yc := float64(ps.Height) / 2.0

	// Create a new WCS object with the affine transformation matrix:
	w := wcs.NewWorldCoordinateSystem(
		xr,
		yr,
		wcs.WCSParams{
			Projection:   wcs.RADEC_TAN,
			AffineParams: params,
			ReferenceX:   xc,
			ReferenceY:   yc,
		},
	)

	return &w, matches, nil
}

/*****************************************************************************************************************/
